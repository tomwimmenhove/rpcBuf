#include <utility>
#include <type_traits>
#include <iostream>

#include <tuple>
#include <iostream>


#include <utility>

using std::cout;
using std::endl;

double foo(int x, float y, double z)
{
	return x + y + z;
}

template <typename T, typename ...Args>
struct call_tuple_args
{
	T (*func)(Args...);

	T operator()(const std::tuple<Args...>& params)
	{
		return call_fn(params, std::make_index_sequence<sizeof...(Args)>{});
	}

	template<typename U, U... ints>
	T call_fn(const std::tuple<Args...>& params, std::integer_sequence<U, ints...>)
	{
		return func(std::get<ints>(params) ...);
	}
};



int main(void)
{
	std::tuple<int, float, double> t = std::make_tuple(1, 1.2f, 5);
	auto f = call_tuple_args<double, int, float, double>{ foo }(t);
	cout << f << endl;
	return 0;
}

struct args
{
	int a;
	int b;
	int c;
};

template<typename T, typename U, typename... Args>
T call_out(Args&&... args)
{
	int return_len;

	if constexpr (!std::is_same<T, void>::value)
	{
		return_len = sizeof(T);
	}
	else
	{
		return_len = 0;
	}

	char ret[return_len];
	T* retp = (T*)ret;

	U a = {std::forward<Args>(args)...};

	*retp = a.b;

	if constexpr (!std::is_same<T, void>::value)
	{
		return *(T*)ret;
	}
}

int mainiac()
{
	int r = call_out<int, args>(5, 6, 7);
	
	std::cout << r << '\n';

	return 0;
}

