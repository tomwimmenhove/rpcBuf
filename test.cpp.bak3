#include <utility>
#include <type_traits>
#include <iostream>

#include <tuple>
#include <iostream>


#include <utility>

using std::cout;
using std::endl;

double foo(int x, float y, double z)
{
	return x + y + z;
}

template <typename T, typename ...Args>
struct call_tuple_args
{
	T (*func)(Args...);

	/* Execute func using the tuple as arguments and return the result */
	T operator()(const std::tuple<Args...>& params)
	{
		return call_fn(params, std::make_index_sequence<sizeof...(Args)>{});
	}
	
	/* Execute func using a tuple pointed to by void pointer 'param_mem' as arguments
	 * and return the result */
	T operator()(void* param_mem)
	{
		return operator()(*(std::tuple<Args...>*) param_mem);
	}

	/* Execute func using a tuple pointed to by void pointer 'param_mem' as arguments
	 * and copy the result into memory pointed to by void pointer 'dest_mem' */
	void src_dest(void* dest_mem, void* param_mem)
	{
		*((T*) dest_mem) = operator()(param_mem);
	}

private:
	template<typename U, U... ints>
	T call_fn(const std::tuple<Args...>& params, std::integer_sequence<U, ints...>)
	{
		return func(std::get<ints>(params) ...);
	}
};



int main(void)
{
	std::tuple<int, float, double> t = std::make_tuple(1, 1.2f, 5);
	double d;

	auto caller = call_tuple_args<double, int, float, double>{ foo };

	caller.src_dest(&d, &t);
	cout << d << endl;

//	auto f = call_tuple_args<double, int, float, double>{ foo }((void*) &t);
//	cout << f << endl;
	return 0;
}

struct args
{
	int a;
	int b;
	int c;
};

template<typename T, typename U, typename... Args>
T call_out(Args&&... args)
{
	int return_len;

	if constexpr (!std::is_same<T, void>::value)
	{
		return_len = sizeof(T);
	}
	else
	{
		return_len = 0;
	}

	char ret[return_len];
	T* retp = (T*)ret;

	U a = {std::forward<Args>(args)...};

	*retp = a.b;

	if constexpr (!std::is_same<T, void>::value)
	{
		return *(T*)ret;
	}
}

int mainiac()
{
	int r = call_out<int, args>(5, 6, 7);
	
	std::cout << r << '\n';

	return 0;
}

