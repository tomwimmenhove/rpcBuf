#include <utility>
#include <type_traits>
#include <iostream>
#include <tuple>
#include <iostream>
#include <utility>
#include <memory>
#include <type_traits>

using std::cout;
using std::endl;

struct caller_base
{
	caller_base(void* fn_ptr)
		: fn_ptr(fn_ptr)
	{ }

	virtual void exec(void* dest_mem, const void* param_mem) { return; }

	size_t get_param_size() { return return_size; }
	size_t get_return_size() { return param_size; }

	virtual ~caller_base()
	{ }

protected:
	size_t param_size;
	size_t return_size;

	void *fn_ptr;
};

template <typename T, typename ...Args>
struct call_tuple_args : caller_base
{
	call_tuple_args(T (*func)(Args...))
		: caller_base((void*) func)
	{
		param_size = sizeof...(Args) ? sizeof(std::tuple<Args...>) : 0;
		
		if constexpr (std::is_same<void, T>::value)
		{
			return_size = 0;
		}
		else
		{
			return_size = sizeof(T);
		}
	}

	/* Execute func using the tuple as arguments and return the result */
	T operator()(const std::tuple<Args...>& params)
	{
		constexpr auto indices = std::make_index_sequence<sizeof...(Args)>{};
		if constexpr (std::is_same<void, T>::value)
		{
			call_fn(params, indices);
		}
		else
		{
			return call_fn(params, indices);
		}
	}
	
	/* Execute func using a tuple pointed to by void pointer 'param_mem' as arguments
	 * and return the result */
	T operator()(const void* param_mem)
	{
		const auto& params = *(std::tuple<Args...>*) param_mem;
		if constexpr (std::is_same<void, T>::value)
		{
			operator()(params);
		}
		else
		{
			return operator()(params);
		}
	}

	/* Execute func using a tuple pointed to by void pointer 'param_mem' as arguments
	 * and copy the result into memory pointed to by void pointer 'dest_mem' */
	void exec(void* dest_mem, const void* param_mem) override
	{
		if constexpr (std::is_same<void, T>::value)
		{
			operator()(param_mem);
		}
		else
		{
			*((T*) dest_mem) = operator()(param_mem);
		}
	}

private:
	template<typename U, U... ints>
	T call_fn(const std::tuple<Args...>& params, std::integer_sequence<U, ints...>)
	{
		auto func = (T (*)(Args...)) fn_ptr;

		if constexpr (std::is_same<void, T>::value)
		{
			func(std::get<ints>(params) ...);
		}
		else
		{
			return func(std::get<ints>(params) ...);
		}
	}
};

double foo(int x, float y, double z) { return x + y + z; }
void bar() { std::cout << "Hello world\n"; }
int square(int a) { return a * a; }

void dummy() { }

caller_base get_caller(int id)
{
	switch(id)
	{
		case 0: return call_tuple_args<double, int, float, double>(foo);
		case 1: return call_tuple_args<void>(bar);
		case 2: return call_tuple_args<int, int>(square);
	}

	return call_tuple_args<void>(dummy);
}

int main(void)
{
	double d;

	std::tuple<int, float, double> t = std::make_tuple(1, 1.2f, 5);
	get_caller(0).exec(&d, &t);
	cout << d << endl;

	std::tuple<> t2 = std::make_tuple();
	get_caller(1).exec(&d, &t2);

	std::cout << "Param  size[0]: " << get_caller(0).get_param_size() << '\n';
	std::cout << "Return size[0]: " << get_caller(0).get_return_size() << '\n';
	
	std::cout << "Param  size[1]: " << get_caller(1).get_param_size() << '\n';
	std::cout << "Return size[1]: " << get_caller(1).get_return_size() << '\n';

	std::cout << "Param  size[2]: " << get_caller(2).get_param_size() << '\n';
	std::cout << "Return size[2]: " << get_caller(2).get_return_size() << '\n';

	return 0;
}

struct args
{
	int a;
	int b;
	int c;
};

template<typename T, typename U, typename... Args>
T call_out(Args&&... args)
{
	int return_len;

	if constexpr (!std::is_same<T, void>::value)
	{
		return_len = sizeof(T);
	}
	else
	{
		return_len = 0;
	}

	char ret[return_len];
	T* retp = (T*)ret;

	U a = {std::forward<Args>(args)...};

	*retp = a.b;

	if constexpr (!std::is_same<T, void>::value)
	{
		return *(T*)ret;
	}
}

int mainiac()
{
	int r = call_out<int, args>(5, 6, 7);
	
	std::cout << r << '\n';

	return 0;
}

